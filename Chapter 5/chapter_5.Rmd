---
title: "Chapter 5"
author: "Icaro Franco Hernandes"
date: "2022-09-26"
output:
  pdf_document: default
  html_document: default
subtitle: Data Transformation
---

```{r setup, eva= TRUE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(knitr)
library(magrittr)
library(nycflights13)
```



Remember that to view a whole data set we can execute, for example, `view(nycflights13::flights)`. This is a tibble, and tibble $\neq$ table. Tibbles work better for the tidyverse. To check what kind of variable we are working with, we can use the following command:
 
```{r}
typeof(nycflights13::flights$time_hour)
```
 
# Filtering

Selecting all flights from January first:
```{r}
nycflights13::flights%>%
  dplyr::filter(month==1,day==1)->jan1
#remeber that dplyr does not change the original dataset (always try to be as pure as possible).
```

If we want to also print the new data set, just put between parenthesis:
```{r}
(nycflights13::flights%>%
  dplyr::filter(month==1,day==1)->jan1)
```

Boolean operators are: `&` for **and**, `|` for **or** and `!` for **is not**.

Inclusion operator: `%in%`. For example:

```{r}
nycflights13::flights%>%
  dplyr::filter(month %in% c(11,12))
```
This will filter all flights that happened in november **or** december. The filter already excludes `NA` values.

## Exercises 5.2.4

### 1
Find all flights that

* Had an arrival delay of two or more hours

```{r}
nycflights13::flights%>%
  dplyr::filter(arr_delay>=120)->f1
```


* Flew to Houston (`IAH` or `HOU`)
```{r}
nycflights13::flights%>%
  dplyr::filter(dest %in% c("IAH", "HOU"))->f2
```

* Were operated by United, American, or Delta

```{r}
nycflights13::flights%>%
  dplyr::filter(carrier %in% c("UA", "AA", "DL"))->f3
```

* Departed in Summer (July, August, and September)

```{r}
nycflights13::flights%>%
  dplyr::filter(month %in% c(7, 8, 9))->fsummer
```

* Arrived more than two hours late, but did not leave late

```{r}
nycflights13::flights%>%
  dplyr::filter(arr_delay>120,dep_time<=sched_dep_time)->f5
```

* Were delayed by at least an hour, but made up over 30 minutes in flight

```{r}
nycflights13::flights%>%
  dplyr::filter(arr_delay>=60,air_time>30)->f6
```

* Departed between midnight and 6am (inclusive)

```{r}
nycflights13::flights%>%
  dplyr::filter(hour %in% c(seq(0,6)))->f7

or

nycflights13::flights%>%
  dplyr::filter(hour >= 0 & hour<= 6)->f71

# nycflights13::flights%>%
#   dplyr::filter(0 <= hour <= 6) -> this does not work!
```

### 2
Another useful `dplyr` filter helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the precious questions?

According to the documentation, `between()` let us pick any values between to boundaries, and it is a shortcut for `x>= & x<=`. They would be useful in the cases where we had to filter for the summer months and the flights between midnight and 6 a.m.:

```{r}
nycflights13::flights%>%
  dplyr::filter(between(month, 7, 9))->f8

nycflights13::flights%>%
  dplyr::filter(between(hour, 0, 6))->f9
```


### 3
How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?

```{r}
nycflights13::flights%>%
  dplyr::filter(is.na(dep_time))%>%
  dplyr::summarise(n = dplyr::n())->na

na

```
Using the count operator from `dplyr` we can see that 8255 flights have missing values for the departure time. This means that theses flights were canceled. If we do not have the departure time, we also cannot check the  airtime, the departure delay and the arrival delay. **Remember this count operator (within the summarise function) from dplyr**.

###  4
Why is `NA^0`not missing? Why is `NA|TRUE` not missing? Whys is `FALSE & NA` not missing? Can you figure out the general rule? (`NA*0` is a tricky counterexample!)

```{r}
NA^0
NA|TRUE
FALSE&NA
```

Since we are working with boolean operators here, the general rule is that R avoids the NA values and does let them contaminate the operation. It is different from the case if we calculate the average of some values with an NA (in that case it does contaminate the average).

```{r}
v1<-c(1,1, NA)
mean(v1)
mean(v1, na.rm = T)

```
The command `na.rm=TRUE` discards the `NA` values from the calculation!

# Arranging



## Exercises 5.3.1

### 1
How could you use `arrange()` to sort all missing values to the start? (Hint: use `is.na()`)

```{r}
v<-tibble::tibble(
  x=(c(3,7,1,NA))
)

x=c(3,7,1,NA)

sort(x, decreasing = FALSE, na.last=FALSE)

```
I used the base R command for sorting.

### 2
Sort `flights` to find the most delayed flights. Find the flights that left earliest.

For the most delayed flights we just need to arrange in descending format:
```{r}
nycflights13::flights%>%
  dplyr::arrange(desc(dep_delay))
```

And for the earliest departures we just need to arrange them:

```{r}
nycflights13::flights%>%
  dplyr::arrange(dep_delay)

```


### 3
Sort `flights` to find the fastest (highest speed) flights

```{r}
nycflights13::flights%>%
  dplyr::select(air_time,
                dplyr::everything())%>%
  dplyr::arrange(air_time)
```


### 4
Which flights traveled the farthest? Which traveled the shortest?

The ones travelled the fartherst:
```{r}
nycflights13::flights%>%
  dplyr::select(distance,
                dplyr::everything())%>%
  dplyr::arrange(desc(distance))
```

The ones that traveled the shortest:

```{r}
nycflights13::flights%>%
  dplyr::select(distance,
                dplyr::everything())%>%
  dplyr::arrange(distance)
```

# Selecting Columns

Selecting by the specific name of each column:
```{r}
nycflights13::flights%>%
  dplyr::select(
    year,
    month,
    day)
```

Selecting an interval of columns:
```{r}
nycflights13::flights%>%
  dplyr::select(
    month:arr_time
  )
```

Negative selection:
```{r}
nycflights13::flights%>%
  dplyr::select(
    -(month:arr_time))
```
The helpers are from `tidyselect`:

* `tidyselect::starts_with("")`

* `tidyselect::ends_with("")`

* `tidyselect::contains("")`

* `tidyselect::matches("")`

* `tidyselect::num_range("")`

We can select a few columns and also the rest of them:
```{r}

nycflights13::flights%>%
  dplyr::select(
    minute,
    distance,
    dplyr::everything())

```






## Exercises 5.4.1

### 1
Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.



### 2
What happens if you include the name of a variable multiple times in a `select()` call?
```{r}
nycflights13::flights%>%
  dplyr::select(
    year,
    minute,
    year) #crime ocorre e nada acontece nesse caso

nycflights13::flights%>%
  dplyr::select(
    year,
    -(year)) #empty vector

nycflights13::flights%>%
  dplyr::select(
    (year:day),
    year)
```

If we include the same column more than one time, the selection takes into account just the first operation. Unless it is a contradictory selection, which is this case we probably get an empty vector.


### 3
What does the `any_of()` function do? Why might if be helpful in conjunction with this vector?

Lets read the documentation:
```{r}
?any_of()

vars<-c("year","month","day","dep_delay","arr_delay")

nycflights13::flights%>%
  dplyr::select(
    any_of(vars))

nycflights13::flights%>%
  dplyr::select(
    -any_of(vars))
```
The `any_of()` command takes a vector of variables and selects columns according to the variables inside the vector. The documentation states that it is useful for negative selections and also that it does not check for errors. It is not clear yet to me what are the advantages.



### 4
Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?

```{r}
nycflights13::flights%>%
  dplyr::select(contains("TIME"))

select(flights, 
       tidyselect::contains("TIME", ignore.case=FALSE))

select(flights, 
       tidyselect::contains("time", ignore.case=FALSE)) #this one should return the same results as the first.

```
The result does surprise. At a first glance we would thought that this selection would return empty vectors, however the default setting of `contains()` ignore the differences between upper and lower case. If we want to make a more precise selection (and make a distinction of upper and lower case) we can add `ignore.case=FALSE`. 
